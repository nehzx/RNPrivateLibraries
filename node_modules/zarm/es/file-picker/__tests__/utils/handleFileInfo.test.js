import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { mocked } from 'ts-jest/utils';
import getFileDetail from '../../utils/getFileDetail';
import handleFileInfo from '../../utils/handleFileInfo';
import createThumbnail from '../../utils/createThumbnail';
import { flushMicroTasks } from '../../../../tests/utils';
jest.mock('../../utils/getFileDetail');
jest.mock('../../utils/createThumbnail');
var mockedGetFileDetail = mocked(getFileDetail);
var mockedCreateThumbnail = mocked(createThumbnail);
describe('file-picker', function () {
  describe('utils', function () {
    afterAll(function () {
      jest.resetAllMocks();
    });
    afterEach(function () {
      jest.clearAllMocks();
    });
    describe('#handleFileInfo', function () {
      it('should get file detail if file is not a picture', function () {
        var file = new File(['foo'], 'foo.txt', {
          type: 'text/plain'
        });
        mockedGetFileDetail.mockReturnValueOnce({
          fileSize: 1000,
          fileType: 'zip',
          isPic: false,
          fileName: 'test'
        });
        var callback = jest.fn();
        handleFileInfo({
          file: file,
          quality: 0.8
        }, callback);
        expect(callback).toBeCalledWith({
          file: file,
          fileName: 'test',
          fileSize: 1000,
          fileType: 'zip',
          thumbnail: ''
        });
        expect(mockedGetFileDetail).toBeCalledWith(file);
      });
      it('should get file detail with thumbnail url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var file, callback;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                file = new File(['foo'], 'foo.txt', {
                  type: 'text/plain'
                });
                mockedGetFileDetail.mockReturnValueOnce({
                  fileSize: 1000,
                  fileType: 'jpg',
                  isPic: true,
                  fileName: 'avatar'
                });
                mockedCreateThumbnail.mockResolvedValueOnce('http://example.cdn.com');
                callback = jest.fn();
                handleFileInfo({
                  file: file,
                  quality: 0.8
                }, callback);
                _context.next = 7;
                return flushMicroTasks();

              case 7:
                expect(callback).toBeCalledWith({
                  file: file,
                  fileName: 'avatar',
                  fileSize: 1000,
                  fileType: 'jpg',
                  thumbnail: 'http://example.cdn.com'
                });
                expect(mockedGetFileDetail).toBeCalledWith(file);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
      it('should print error if create thumbnail fail', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var file, err, callback, errorLogStub;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                file = new File(['foo'], 'foo.txt', {
                  type: 'text/plain'
                });
                mockedGetFileDetail.mockReturnValueOnce({
                  fileSize: 1000,
                  fileType: 'jpg',
                  isPic: true,
                  fileName: 'avatar'
                });
                err = new Error('memory leak');
                mockedCreateThumbnail.mockRejectedValueOnce(err);
                callback = jest.fn();
                errorLogStub = jest.spyOn(console, 'error').mockReturnValueOnce();
                handleFileInfo({
                  file: file,
                  quality: 0.8
                }, callback);
                _context2.next = 9;
                return flushMicroTasks();

              case 9:
                expect(callback).not.toBeCalled();
                expect(mockedGetFileDetail).toBeCalledWith(file);
                expect(errorLogStub).toBeCalledWith(err);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));
    });
  });
});