import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React from 'react';
import ReactDOM, { createPortal } from 'react-dom';
import PopperJS from 'popper.js';
import classnames from 'classnames';
import ClickOutside from '../click-outside';
import { canUseDOM, getOuterSizes } from '../utils/dom';
import { directionMap } from './PropsType';
import Events from '../utils/events';

var invertKeyValues = function invertKeyValues(obj, fn) {
  return Object.keys(obj).reduce(function (acc, key) {
    var val = fn ? fn(obj[key]) : obj[key];
    acc[val] = acc[val] || [];
    acc[val].push(key);
    return acc;
  }, {});
};

var getPopperClientRect = function getPopperClientRect(popperOffsets) {
  var offsets = _objectSpread({}, popperOffsets);

  offsets.right = offsets.left + offsets.width;
  offsets.bottom = offsets.top + offsets.height;
  return offsets;
};

var setTransformOrigin = function setTransformOrigin(domNode) {
  var placement = domNode.getAttribute('x-placement');
  var transformOrigin = {
    'top-start': 'left bottom',
    top: 'center bottom',
    'top-end': 'right bottom',
    'left-start': 'right top',
    left: 'right center',
    'left-end': 'right bottom',
    'bottom-start': 'left top',
    bottom: 'center top',
    'bottom-end': 'right top',
    'right-start': 'left top',
    right: 'left center',
    'right-end': 'left bottom'
  };
  domNode.style.transformOrigin = transformOrigin[placement];
};

var customArrowOffsetFn = function customArrowOffsetFn(data) {
  var _data$placement$split = data.placement.split('-'),
      _data$placement$split2 = _slicedToArray(_data$placement$split, 2),
      placement = _data$placement$split2[0],
      placement1 = _data$placement$split2[1];

  var arrow = data.instance.options.modifiers && data.instance.options.modifiers.arrow.element;
  var reference = data.offsets.reference;
  var popper = getPopperClientRect(data.offsets.popper);
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var side = isVertical ? 'top' : 'left';
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowSize = getOuterSizes(arrow)[len];
  var offsetSize = parseFloat(getComputedStyle(data.instance.popper, null).paddingLeft);
  var hashMap = {
    start: side === 'top' || side === 'left' ? reference[side] + offsetSize : reference[opSide] - offsetSize - arrowSize,
    center: reference[side] + reference[len] / 2 - arrowSize / 2,
    end: side === 'top' || side === 'left' ? reference[opSide] - offsetSize - arrowSize : reference[side] + offsetSize
  };
  var place = hashMap[placement1 || 'center'];
  var sideValue = place - popper[side];
  data.arrowElement = arrow;
  data.arrowStyles[side] = Math.floor(sideValue).toString();
  data.arrowStyles[altSide] = '';
  return data;
};

var popperInstances = new Set();

var Popper = /*#__PURE__*/function (_React$Component) {
  _inherits(Popper, _React$Component);

  var _super = _createSuper(Popper);

  function Popper() {
    var _this;

    _classCallCheck(this, Popper);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.popper = void 0;
    _this.popperNode = void 0;
    _this.reference = void 0;
    _this.arrowRef = void 0;
    _this.enterTimer = void 0;
    _this.leaveTimer = void 0;
    _this.state = {
      show: false,
      direction: _this.props.direction,
      arrowRef: null,
      mounted: false,
      isPending: false,
      animationState: 'leave'
    };

    _this.handleOpen = function () {
      var _this$props = _this.props,
          direction = _this$props.direction,
          hasArrow = _this$props.hasArrow,
          arrowPointAtCenter = _this$props.arrowPointAtCenter;
      var reference = _this.reference;
      var popperNode = _this.popperNode;

      if (!popperNode) {
        return;
      }

      if (_this.popper) {
        _this.destroy();
      }

      _this.popper = new PopperJS(reference, popperNode, {
        placement: directionMap[direction],
        modifiers: {
          preventOverflow: {
            boundariesElement: 'window'
          },
          computeStyle: {
            gpuAcceleration: false
          },
          arrow: _objectSpread({
            enabled: Boolean(_this.arrowRef),
            element: _this.arrowRef
          }, !(hasArrow && arrowPointAtCenter) && {
            fn: customArrowOffsetFn
          })
        },
        onCreate: _this.handlePopperUpdate,
        onUpdate: _this.handlePopperUpdate
      });
      Events.on(_this.popperNode, 'webkitAnimationEnd', _this.animationEnd);
      Events.on(_this.popperNode, 'animationend', _this.animationEnd);

      _this.enter();

      popperInstances.add(_this.popper);
    };

    _this.animationEnd = function (e) {
      e.stopPropagation();
      var animationState = _this.state.animationState;
      var destroy = _this.props.destroy;

      if (animationState === 'leave') {
        _this.setState(_objectSpread({
          show: false,
          isPending: false
        }, destroy && {
          mounted: false
        }), function () {
          _this.destroy();

          _this.props.onVisibleChange(false);
        });
      } else {
        _this.props.onVisibleChange(true);
      }
    };

    _this.handlePopperUpdate = function (data) {
      var animationType = _this.props.animationType;
      if (animationType !== 'menuSlide') setTransformOrigin(_this.popperNode);

      if (data.placement !== _this.state.direction) {
        _this.setState({
          direction: invertKeyValues(directionMap)[data.placement]
        });
      }
    };

    _this.handleClose = function () {
      if (!_this.popper) {
        return;
      }

      _this.leave();
    };

    _this.handleClick = function (event) {
      var trigger = _this.props.trigger;
      var show = _this.state.show;
      if (trigger === 'contextMenu') event.preventDefault();

      _this.setState({
        mounted: true
      }, function () {
        if (!show) {
          _this.handleOpen();
        } else {
          _this.handleClose();
        }
      });
    };

    _this.handleEnter = function (event) {
      var _this$props2 = _this.props,
          children = _this$props2.children,
          mouseEnterDelay = _this$props2.mouseEnterDelay;
      var childrenProps = children.props;

      if ( /*#__PURE__*/React.isValidElement(children) && event.type === 'mouseover' && childrenProps.onMouseOver) {
        childrenProps.onMouseOver(event);
      }

      clearTimeout(_this.enterTimer);
      clearTimeout(_this.leaveTimer);
      _this.enterTimer = window.setTimeout(function () {
        _this.setState({
          mounted: true
        }, _this.handleOpen);
      }, mouseEnterDelay);
    };

    _this.handleLeave = function (event) {
      var _this$props3 = _this.props,
          children = _this$props3.children,
          mouseLeaveDelay = _this$props3.mouseLeaveDelay;
      var childrenProps = children.props;

      if ( /*#__PURE__*/React.isValidElement(children) && event.type === 'blur' && childrenProps.onBlur) {
        childrenProps.onBlur(event);
      }

      if ( /*#__PURE__*/React.isValidElement(children) && event.type === 'mouseleave' && childrenProps.onMouseLeave) {
        childrenProps.onMouseLeave(event);
      }

      clearTimeout(_this.enterTimer);
      clearTimeout(_this.leaveTimer);
      _this.leaveTimer = window.setTimeout(function () {
        _this.handleClose();
      }, mouseLeaveDelay);
    };

    return _this;
  }

  _createClass(Popper, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props4 = this.props,
          direction = _this$props4.direction,
          visible = _this$props4.visible;

      if (visible && (prevProps.visible !== visible || prevProps.direction !== direction)) {
        this.handleOpen();
      }

      if (prevProps.visible !== visible && !visible) {
        this.handleClose();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.popperNode) {
        Events.off(this.popperNode, 'webkitAnimationEnd', this.animationEnd);
        Events.off(this.popperNode, 'animationend', this.animationEnd);
      }

      this.destroy();
      clearTimeout(this.enterTimer);
      clearTimeout(this.leaveTimer);
    }
  }, {
    key: "getPopperDomNode",
    value: function getPopperDomNode() {
      return this.popperNode;
    }
  }, {
    key: "getTransitionName",
    value: function getTransitionName(animationType, animationState) {
      if (this.popperNode) {
        var placement = this.popperNode.getAttribute('x-placement');

        if (animationType === 'menuSlide' && placement) {
          if (placement.includes('top')) {
            return "za-".concat(animationType, "-down-").concat(animationState);
          }

          return "za-".concat(animationType, "-up-").concat(animationState);
        }

        return "za-".concat(animationType, "-").concat(animationState);
      }
    }
  }, {
    key: "mountContainer",
    value: function mountContainer() {
      var mountContainer = this.props.mountContainer;

      if (mountContainer) {
        if (typeof mountContainer === 'function') {
          return mountContainer();
        }

        if (_typeof(mountContainer) === 'object' && mountContainer instanceof HTMLElement) {
          return mountContainer;
        }
      }

      return document.body;
    }
  }, {
    key: "enter",
    value: function enter() {
      this.setState({
        show: true,
        isPending: true,
        animationState: 'enter'
      });
    }
  }, {
    key: "leave",
    value: function leave() {
      this.setState({
        show: false,
        isPending: true,
        animationState: 'leave'
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.popper) {
        this.popper.destroy();
        popperInstances.delete(this.popper);
        this.popper = null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classnames,
          _this2 = this;

      var _this$props5 = this.props,
          children = _this$props5.children,
          content = _this$props5.content,
          prefixCls = _this$props5.prefixCls,
          className = _this$props5.className,
          trigger = _this$props5.trigger,
          hasArrow = _this$props5.hasArrow,
          animationType = _this$props5.animationType,
          animationDuration = _this$props5.animationDuration,
          style = _this$props5.style;
      var _this$state = this.state,
          direction = _this$state.direction,
          mounted = _this$state.mounted,
          animationState = _this$state.animationState,
          isPending = _this$state.isPending;
      var transitionName = this.getTransitionName(animationType, animationState);
      var innerCls = classnames(className, prefixCls, "".concat(prefixCls, "--").concat(direction), (_classnames = {}, _defineProperty(_classnames, "".concat(prefixCls, "--hidden"), animationState === 'leave'), _defineProperty(_classnames, transitionName, isPending), _classnames));
      var child = /*#__PURE__*/React.isValidElement(children) ? children : /*#__PURE__*/React.createElement("span", null, children);

      var childrenProps = _objectSpread({}, children && children.props);

      var event = {};

      if (trigger === 'click') {
        childrenProps.onClick = this.handleClick;
      }

      if (trigger === 'contextMenu') {
        childrenProps.onContextMenu = this.handleClick;
      }

      if (trigger === 'hover') {
        childrenProps.onMouseOver = this.handleEnter;
        childrenProps.onMouseLeave = this.handleLeave;
        event.onMouseOver = this.handleEnter;
        event.onMouseLeave = this.handleLeave;
      }

      if (trigger === 'focus') {
        childrenProps.onFocus = this.handleClick; // childrenProps.onBlur = this.handleLeave;
      }

      var toolTip = /*#__PURE__*/React.createElement(ClickOutside, {
        onClickOutside: this.handleClose,
        ignoredNode: this.reference,
        className: "".concat(prefixCls, "-container"),
        disabled: trigger === 'manual'
      }, /*#__PURE__*/React.createElement("div", _extends({
        role: "tooltip",
        style: _objectSpread(_objectSpread({
          position: 'absolute',
          animationDuration: "".concat(animationDuration, "ms")
        }, animationState === 'leave' && !isPending && {
          display: 'none'
        }), style),
        className: innerCls,
        ref: function ref(node) {
          _this2.popperNode = node;
        }
      }, event), /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "__content")
      }, content), hasArrow && /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixCls, "__arrow"),
        ref: function ref(el) {
          _this2.arrowRef = el;
        }
      })));
      return /*#__PURE__*/React.createElement(React.Fragment, null, mounted && /*#__PURE__*/createPortal(toolTip, this.mountContainer()), /*#__PURE__*/React.cloneElement(child, _objectSpread({
        ref: function ref(node) {
          // eslint-disable-next-line react/no-find-dom-node
          _this2.reference = ReactDOM.findDOMNode(node);
        }
      }, childrenProps)));
    }
  }], [{
    key: "update",
    value: function update() {
      popperInstances.forEach(function (popperInstance) {
        return popperInstance.scheduleUpdate();
      });
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ('visible' in props && props.trigger === 'manual') {
        return _objectSpread(_objectSpread({}, state), {}, {
          show: props.visible
        }, props.visible && {
          mounted: true
        });
      }

      return null;
    }
  }]);

  return Popper;
}(React.Component);

Popper.defaultProps = {
  prefixCls: 'za-popper',
  hasArrow: false,
  destroy: true,
  arrowPointAtCenter: false,
  trigger: (canUseDOM && /(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent) ? 'click' : 'hover') || 'click',
  direction: 'top',
  mouseEnterDelay: 150,
  mouseLeaveDelay: 100,
  visible: false,
  content: '',
  animationType: 'zoomFade',
  animationDuration: 300,
  onVisibleChange: function onVisibleChange() {}
};
export default Popper;