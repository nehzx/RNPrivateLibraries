import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable @typescript-eslint/no-var-requires */

/* eslint-disable dot-notation */

/* eslint-disable no-unused-expressions */
import React from 'react';
import { mount, shallow } from 'enzyme';
import toJson from 'enzyme-to-json';
import ReactDOM from 'react-dom';
import Portal from '../Portal';
import Popup from '../Popup';
import Events from '../../utils/events';
import Trigger from '../../trigger';
import Mask from '../../mask';
describe('Popup', function () {
  describe('snapshot', function () {
    it('renders correctly', function () {
      var onMaskClick = jest.fn();
      var afterClose = jest.fn();
      var wrapper = mount( /*#__PURE__*/React.createElement(Popup, {
        direction: "bottom",
        onMaskClick: onMaskClick,
        afterClose: afterClose
      }, "foo"));
      expect(toJson(wrapper)).toMatchSnapshot();
    });
    it('renders mount node correctly', function () {
      var onMaskClick = jest.fn();
      var afterClose = jest.fn();
      var wrapper = mount( /*#__PURE__*/React.createElement(Popup, {
        visible: true,
        direction: "bottom",
        onMaskClick: onMaskClick,
        afterClose: afterClose,
        mountContainer: function mountContainer() {
          return document.body;
        }
      }, "foo"));
      expect(toJson(wrapper)).toMatchSnapshot();
    });
    it('renders mount without mountContainer', function () {
      var onMaskClick = jest.fn();
      var afterClose = jest.fn();
      var wrapper = mount( /*#__PURE__*/React.createElement(Popup, {
        visible: true,
        direction: "bottom",
        onMaskClick: onMaskClick,
        afterClose: afterClose,
        mountContainer: false
      }, "foo"));
      expect(toJson(wrapper)).toMatchSnapshot();
    });
  });
  it('should render portal if props.visible is truthy', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(Popup, {
      visible: true
    }));
    expect(wrapper.state()).toEqual({
      renderPortal: true,
      portalVisible: true
    });
    expect(wrapper.exists()).toBeTruthy();
  });
  it('should not render portal if props.visible is falsy', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(Popup, null));
    expect(wrapper.state()).toEqual({
      renderPortal: false,
      portalVisible: false
    });
    expect(wrapper.find(Portal).exists()).toBeFalsy();
  });
  it('should create portal ref', function () {
    var wrapper = mount( /*#__PURE__*/React.createElement(Popup, {
      visible: true
    }));
    expect(wrapper.instance()['portalRef']).toBeInstanceOf(Portal);
  });
  it('should destroy(unmount) portal from component tree', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(Popup, {
      visible: true,
      destroy: true
    }));
    wrapper.instance()['handlePortalUnmount']();
    expect(wrapper.state()).toEqual({
      renderPortal: false,
      portalVisible: true
    });
    expect(wrapper.find(Portal).exists()).toBeFalsy();
  }); // TODO: the logic probably incorrect, getDerivedStateFromProps will be triggered after setState
  // The state will be updated to { renderPortal: true, portalVisible: true }

  it('should not destroy(unmount) portal from component tree but set to invisible', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(Popup, {
      visible: true,
      destroy: false
    }));
    wrapper.instance()['handlePortalUnmount']();
    expect(wrapper.state()).toEqual({
      renderPortal: true,
      portalVisible: true
    });
    expect(wrapper.find(Portal).exists()).toBeTruthy();
    expect(wrapper.find(Portal).prop('visible')).toBeTruthy();
  });
  it('should pass correct props to Portal', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(Popup, {
      visible: true
    }));
    expect(wrapper.prop('destroy')).toBeTruthy();
  });
});
describe('Portal', function () {
  var PortalCJS;
  var events = ['webkitTransitionEnd', 'transitionend', 'webkitAnimationEnd', 'animationend'];
  beforeEach(function () {
    jest.resetModules();
    jest.dontMock('../../utils/dom');
    jest.dontMock('react-dom');
  });
  afterEach(function () {
    jest.restoreAllMocks();
  });
  it('should bind transitionend and animationend events for popup element', function () {
    expect.assertions(events.length);
    var eventsOnSpy = jest.spyOn(Events, 'on').mockImplementation();
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, null));
    events.forEach(function (e) {
      expect(eventsOnSpy).toBeCalledWith(wrapper.instance()['popup'], e, expect.any(Function));
    });
  });
  it('should unbind transitionend and animationend events for popup element and do cleanup work', function () {
    expect.assertions(events.length + 2);
    var popupRef;
    Object.defineProperty(Portal.prototype, 'popup', {
      get: function get() {
        return this._popup;
      },
      set: function set(ref) {
        if (ref) {
          popupRef = ref;
        }

        this._popup = ref;
      },
      configurable: true
    });
    var clearTimeoutSpy = jest.spyOn(window, 'clearTimeout').mockImplementation();
    var eventsOffSpy = jest.spyOn(Events, 'off').mockImplementation();
    var mountContainer = document.createElement('div');
    document.body.appendChild(mountContainer);
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      mountContainer: mountContainer
    }));
    wrapper.unmount();
    events.forEach(function (e) {
      expect(eventsOffSpy).toBeCalledWith(popupRef, e, expect.any(Function));
    });
    expect(clearTimeoutSpy).toBeCalledTimes(1);
    expect(mountContainer.querySelector('.za-popup-container')).toBeFalsy();
  });
  it('should not handle animation if prevProps visible equal with current props visible', function () {
    var setStateSpy = jest.spyOn(Portal.prototype, 'setState');
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, null));
    expect(wrapper.state('isPending')).toBeTruthy();
    wrapper.setProps({
      visible: false
    });
    expect(setStateSpy).toBeCalledTimes(1);
  });
  it('should create container inside document.body', function () {
    var createElementSpy = jest.spyOn(document, 'createElement');
    var appendChildSpy = jest.spyOn(document.body, 'appendChild');
    mount( /*#__PURE__*/React.createElement(Portal, {
      mountContainer: document.body
    }));
    expect(createElementSpy).toBeCalledWith('div');
    var container = document.body.querySelector('.za-popup-container');
    expect(container).toBeTruthy();
    expect(container.className).toEqual('za-popup-container');
    expect(appendChildSpy).toBeCalledTimes(1);
  });
  it('should not create container if mount container is falsy', function () {
    var createElementSpy = jest.spyOn(document, 'createElement');
    shallow( /*#__PURE__*/React.createElement(Portal, {
      mountContainer: false
    }));
    expect(createElementSpy).not.toBeCalled();
  });
  it('should render null if canUseDOM is false', function () {
    jest.doMock('../../utils/dom', function () {
      var origin = jest.requireActual('../../utils/dom');
      return _objectSpread(_objectSpread({}, origin), {}, {
        canUseDOM: false
      });
    });
    PortalCJS = require('../Portal').default;
    var wrapper = mount( /*#__PURE__*/React.createElement(PortalCJS, null));
    expect(wrapper.find(Trigger).children()).toHaveLength(0);
  });
  it('should render popup and its children without mask', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(Portal, {
      mask: false
    }, /*#__PURE__*/React.createElement("div", {
      id: "test"
    }, "test")));
    var popup = wrapper.find('[role="dialog"]');
    expect(popup.exists()).toBeTruthy();
    expect(popup.prop('className')).toEqual('za-popup za-popup--bottom');
    expect(popup.find('#test').text()).toEqual('test');
  });
  it('should render popup with normal mask which will perform a fade in animation', function () {
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      visible: true,
      maskType: "normal"
    }));
    expect(wrapper.find(Mask).exists()).toBeTruthy();
    expect(wrapper.find(Mask).props()).toEqual(expect.objectContaining({
      className: 'za-fade-enter',
      style: {
        WebkitAnimationDuration: "200ms",
        animationDuration: "200ms"
      },
      visible: true,
      type: 'normal'
    }));
  });
  it('should render a transparent mask which will perform a fade out animation', function () {
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      maskType: "transparent"
    }));
    expect(wrapper.find(Mask).exists()).toBeTruthy();
    expect(wrapper.find(Mask).props()).toEqual(expect.objectContaining({
      className: 'za-fade-leave',
      style: {
        WebkitAnimationDuration: "200ms",
        animationDuration: "200ms"
      },
      visible: true,
      type: 'transparent'
    }));
  });
  it('should render portal inside the popup container html div element (react version >= 16)', function () {
    var createPortalSpy = jest.spyOn(ReactDOM, 'createPortal');
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      mask: false,
      mountContainer: document.body
    }));
    var popupContainer = document.body.querySelector('.za-popup-container');
    expect(popupContainer.querySelector('[role="dialog"]')).toBeTruthy();
    expect(createPortalSpy).toBeCalled();
    var portal = wrapper.find(Trigger).childAt(0);
    expect(portal.exists()).toBeTruthy();
    expect(portal.name()).toBe('Portal');
    expect(portal.type().toString()).toBe('Symbol(react.portal)');
  });
  it('should render portal inside the popup container html div element (react version < 16)', function () {
    var _require = require('react-dom'),
        createPortal = _require.createPortal; // eslint-disable-next-line camelcase


    var unstable_renderSubtreeIntoContainerProxy = jest.fn(function (_, element, container) {
      createPortal(element, container);
    });
    jest.doMock('react-dom', function () {
      var origin = jest.requireActual('react-dom');
      return _objectSpread(_objectSpread({}, origin), {}, {
        unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainerProxy,
        createPortal: undefined
      });
    });
    PortalCJS = require('../Portal').default;
    mount( /*#__PURE__*/React.createElement(PortalCJS, {
      mask: false,
      mountContainer: document.body
    }));
    expect(unstable_renderSubtreeIntoContainerProxy).toBeCalled();
  });
  it('should handle ESC keyboard input', function () {
    var mOnEsc = jest.fn();
    var wrapper = shallow( /*#__PURE__*/React.createElement(Portal, {
      onEsc: mOnEsc
    }));
    wrapper.invoke('onClose')();
    expect(mOnEsc).toBeCalledTimes(1);
  });
  it('should handle mask click', function () {
    var mOnMaskClick = jest.fn();
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      onMaskClick: mOnMaskClick
    }));
    var maskWrapper = wrapper.find('.za-popup__wrapper');
    var mEvent = {
      stopPropagation: jest.fn()
    };
    maskWrapper.simulate('click', mEvent);
    expect(mEvent.stopPropagation).toBeCalledTimes(1);
    expect(mOnMaskClick).toBeCalledTimes(1);
  });
  it('should not handle mask click if popup ref is event target', function () {
    var popupRef;
    Object.defineProperty(Portal.prototype, 'popup', {
      get: function get() {
        return this._popup;
      },
      set: function set(ref) {
        if (ref) {
          popupRef = ref;
        }

        this._popup = ref;
      },
      configurable: true
    });
    var mOnMaskClick = jest.fn();
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      onMaskClick: mOnMaskClick
    }));
    var maskWrapper = wrapper.find('.za-popup__wrapper');
    var mEvent = {
      stopPropagation: jest.fn(),
      target: popupRef
    };
    maskWrapper.simulate('click', mEvent);
    expect(mEvent.stopPropagation).toBeCalledTimes(1);
    expect(mOnMaskClick).not.toBeCalled();
  });
  it('should not handle animation end event if event target is popup ref', function () {
    var handlerRef;
    jest.spyOn(Events, 'on').mockImplementationOnce(function (_, __, handler) {
      handlerRef = handler;
    });
    var mAfterOpen = jest.fn();
    mount( /*#__PURE__*/React.createElement(Portal, {
      visible: true,
      afterOpen: mAfterOpen
    }));
    var mEvent = {
      stopPropagation: jest.fn()
    };
    handlerRef(mEvent);
    expect(mEvent.stopPropagation).not.toBeCalled();
  });
  it('should handle animation end event if animation state is leave', function () {
    var handlerRef;
    jest.spyOn(Events, 'on').mockImplementationOnce(function (_, __, handler) {
      handlerRef = handler;
    });
    var mHandlePortalUnmount = jest.fn();
    var mAfterClose = jest.fn();
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      handlePortalUnmount: mHandlePortalUnmount,
      afterClose: mAfterClose
    }));
    var popupRef = wrapper.instance()['popup'];
    var mEvent = {
      stopPropagation: jest.fn(),
      target: popupRef
    };
    handlerRef(mEvent);
    expect(wrapper.instance()['_container'].className).toEqual('za-popup-container za-popup--hidden');
    expect(mEvent.stopPropagation).toBeCalledTimes(1);
    expect(mHandlePortalUnmount).toBeCalledTimes(1);
    expect(mAfterClose).toBeCalledTimes(1);
  });
  it('should handle animation end event if animation state is enter', function () {
    var handlerRef;
    jest.spyOn(Events, 'on').mockImplementationOnce(function (_, __, handler) {
      handlerRef = handler;
    });
    var mAfterOpen = jest.fn();
    var wrapper = mount( /*#__PURE__*/React.createElement(Portal, {
      visible: true,
      afterOpen: mAfterOpen
    }));
    var popupRef = wrapper.instance()['popup'];
    var mEvent = {
      stopPropagation: jest.fn(),
      target: popupRef
    };
    handlerRef(mEvent);
    expect(mEvent.stopPropagation).toBeCalledTimes(1);
    expect(mAfterOpen).toBeCalledTimes(1);
  });
});