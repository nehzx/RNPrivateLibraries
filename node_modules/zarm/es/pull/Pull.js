import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { PureComponent } from 'react';
import classnames from 'classnames';
import { SuccessCircle as SuccessCircleIcon, WarningCircle as WarningCircleIcon } from '@zarm-design/icons';
import { REFRESH_STATE, LOAD_STATE } from './PropsType';
import Events from '../utils/events';
import Throttle from '../utils/throttle';
import { getScrollTop } from '../utils/dom';
import Drag from '../drag';
import ActivityIndicator from '../activity-indicator';

var Pull = /*#__PURE__*/function (_PureComponent) {
  _inherits(Pull, _PureComponent);

  var _super = _createSuper(Pull);

  function Pull(props) {
    var _this;

    _classCallCheck(this, Pull);

    _this = _super.call(this, props);
    _this.pull = void 0;
    _this.wrap = void 0;
    _this.throttledScroll = void 0;
    _this.wrapTouchstartY = void 0;
    _this.mounted = true;

    _this.getScrollContainer = function () {
      if (process.env.NODE_ENV !== 'production') {
        console.warn("Warning: getScrollContainer() has been renamed, and is not recommended for use.\n\n* Rename `getScrollContainer()` to `scrollContainer` to suppress this warning.");
      }

      return _this.scrollContainer;
    };

    _this.wrapTouchstart = function (event) {
      var touch = event.touches[0];
      _this.wrapTouchstartY = touch.pageY;
    };

    _this.wrapTouchmove = function (event) {
      var touch = event.touches[0];
      var currentY = touch.pageY;

      if (currentY - _this.wrapTouchstartY > 0 && event.cancelable && _this.scrollTop === 0) {
        event.preventDefault();
      }
    };

    _this.wrapTouchEnd = function () {
      _this.wrapTouchstartY = 0;

      _this.setState({
        animationDuration: _this.props.animationDuration
      });
    };

    _this.addEvent = function () {
      // scrollContainer 未变更
      if (_this.wrap === _this.scrollContainer) return; // 解除事件监听

      if (_this.wrap) {
        _this.removeEvent();
      } // 重新获取 scrollContainer


      _this.wrap = _this.scrollContainer; // 监听事件

      Events.on(_this.wrap, 'scroll', _this.throttledScroll);
      Events.on(_this.wrap, 'touchstart', _this.wrapTouchstart);
      Events.on(_this.wrap, 'touchmove', _this.wrapTouchmove);
      Events.on(_this.wrap, 'touchend', _this.wrapTouchEnd);
    };

    _this.removeEvent = function () {
      Events.off(_this.wrap, 'scroll', _this.throttledScroll);
      Events.off(_this.wrap, 'touchstart', _this.wrapTouchstart);
      Events.off(_this.wrap, 'touchmove', _this.wrapTouchmove);
      Events.off(_this.wrap, 'touchend', _this.wrapTouchEnd);
    };

    _this.onScroll = function () {
      var _this$state = _this.state,
          refreshState = _this$state.refreshState,
          loadState = _this$state.loadState; // window为滚动容器时，无法通过 window 直接取到 scrollHeight 和 clientHeight。

      var _this$wrap = _this.wrap,
          _this$wrap$scrollHeig = _this$wrap.scrollHeight,
          scrollHeight = _this$wrap$scrollHeig === void 0 ? document.body.clientHeight : _this$wrap$scrollHeig,
          _this$wrap$clientHeig = _this$wrap.clientHeight,
          clientHeight = _this$wrap$clientHeig === void 0 ? document.documentElement.clientHeight : _this$wrap$clientHeig;

      var load = _objectSpread(_objectSpread({}, Pull.defaultProps.load), _this.props.load);

      var handler = load.handler,
          distance = load.distance;

      if (typeof handler !== 'function' || refreshState !== REFRESH_STATE.normal || loadState !== LOAD_STATE.normal || scrollHeight <= clientHeight || // 内容高度 - 偏移值 - 修正距离 <= 容器可见高度
      scrollHeight - _this.scrollTop - distance > clientHeight) {
        return;
      }

      handler();
    };

    _this.onDragMove = function (event, _ref) {
      var offsetY = _ref.offsetY;
      var _ref2 = _this.props.refresh,
          handler = _ref2.handler;

      if ( // 未设置刷新事件
      !handler || // 上拉
      offsetY <= 0 || // 未滚动到顶部
      offsetY > 0 && _this.scrollTop > 0 || // 已经触发过加载状态
      _this.state.refreshState >= REFRESH_STATE.loading) {
        return false;
      } // 解决低端安卓系统只触发一次touchmove事件的bug


      if (!Events.supportsPassiveEvents) {
        event.preventDefault();
      }

      var refresh = _objectSpread(_objectSpread({}, Pull.defaultProps.refresh), _this.props.refresh);

      var startDistance = refresh.startDistance,
          distance = refresh.distance; // 设置拖动距离衰减（实际下拉移动距离为拖动距离的1/3）

      var offset = offsetY / 3; // 判断是否达到释放立即刷新的条件

      var action = offset - startDistance < distance ? REFRESH_STATE.pull : REFRESH_STATE.drop;

      _this.doRefreshAction(action, offset);

      return true;
    };

    _this.onDragEnd = function (_event, _ref3) {
      var offsetY = _ref3.offsetY;

      // 没有产生位移
      if (!offsetY) {
        return;
      } // 当前状态为下拉状态时


      var refreshState = _this.state.refreshState;

      if (refreshState === REFRESH_STATE.pull) {
        _this.doRefreshAction(REFRESH_STATE.normal);

        return;
      } // 执行外部触发刷新的回调


      var _ref4 = _this.props.refresh,
          handler = _ref4.handler;

      if (typeof handler === 'function') {
        handler();
      }
    };

    _this.doTransition = function (_ref5) {
      var offsetY = _ref5.offsetY,
          animationDuration = _ref5.animationDuration;

      _this.setState({
        offsetY: offsetY,
        animationDuration: animationDuration
      });
    };

    _this.doRefreshAction = function (refreshState, offsetY) {
      var _this$props = _this.props,
          animationDuration = _this$props.animationDuration,
          stayTime = _this$props.stayTime;

      _this.setState({
        refreshState: refreshState
      });

      switch (refreshState) {
        case REFRESH_STATE.pull:
        case REFRESH_STATE.drop:
          _this.doTransition({
            offsetY: offsetY,
            animationDuration: 0
          });

          break;

        case REFRESH_STATE.loading:
          _this.doTransition({
            offsetY: 'auto',
            animationDuration: animationDuration
          });

          break;

        case REFRESH_STATE.success:
        case REFRESH_STATE.failure:
          _this.doTransition({
            offsetY: 'auto',
            animationDuration: animationDuration
          });

          setTimeout(function () {
            if (!_this.mounted) return;

            _this.doRefreshAction(REFRESH_STATE.normal);

            _this.doLoadAction(LOAD_STATE.normal);
          }, stayTime);
          break;

        default:
          _this.doTransition({
            offsetY: 0,
            animationDuration: animationDuration
          });

      }
    };

    _this.doLoadAction = function (loadState) {
      var stayTime = _this.props.stayTime;

      _this.setState({
        loadState: loadState
      });

      switch (loadState) {
        case LOAD_STATE.success:
          _this.doLoadAction(LOAD_STATE.normal);

          break;

        case LOAD_STATE.failure:
          setTimeout(function () {
            if (!_this.mounted) return;

            _this.doLoadAction(LOAD_STATE.abort);
          }, stayTime);
          break;

        default:
      }
    };

    _this.renderRefresh = function () {
      var refresh = _objectSpread(_objectSpread({}, Pull.defaultProps.refresh), _this.props.refresh);

      var startDistance = refresh.startDistance,
          distance = refresh.distance,
          render = refresh.render;
      var _this$state2 = _this.state,
          refreshState = _this$state2.refreshState,
          offsetY = _this$state2.offsetY;
      var percent = 0;

      if (offsetY >= startDistance) {
        percent = (offsetY - startDistance < distance ? offsetY - startDistance : distance) * 100 / distance;
      }

      if (typeof render === 'function') {
        return render(refreshState, percent);
      }

      var _this$props2 = _this.props,
          prefixCls = _this$props2.prefixCls,
          locale = _this$props2.locale;
      var cls = "".concat(prefixCls, "__control");

      switch (refreshState) {
        case REFRESH_STATE.pull:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(ActivityIndicator, {
            loading: false,
            percent: percent
          }), /*#__PURE__*/React.createElement("span", null, locale.pullText));

        case REFRESH_STATE.drop:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(ActivityIndicator, {
            loading: false,
            percent: 100
          }), /*#__PURE__*/React.createElement("span", null, locale.dropText));

        case REFRESH_STATE.loading:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(ActivityIndicator, {
            type: "spinner"
          }), /*#__PURE__*/React.createElement("span", null, locale.loadingText));

        case REFRESH_STATE.success:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(SuccessCircleIcon, {
            theme: "success"
          }), /*#__PURE__*/React.createElement("span", null, locale.successText));

        case REFRESH_STATE.failure:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(WarningCircleIcon, {
            theme: "danger"
          }), /*#__PURE__*/React.createElement("span", null, locale.failureText));

        default:
      }
    };

    _this.renderLoad = function () {
      var load = _objectSpread(_objectSpread({}, Pull.defaultProps.load), _this.props.load);

      var render = load.render;
      var loadState = _this.state.loadState;

      if (typeof render === 'function') {
        return render(loadState);
      }

      var _this$props3 = _this.props,
          prefixCls = _this$props3.prefixCls,
          locale = _this$props3.locale;
      var cls = "".concat(prefixCls, "__control");

      switch (loadState) {
        case LOAD_STATE.loading:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(ActivityIndicator, {
            type: "spinner"
          }), /*#__PURE__*/React.createElement("span", null, locale.loadingText));

        case LOAD_STATE.failure:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement(WarningCircleIcon, {
            theme: "danger"
          }), /*#__PURE__*/React.createElement("span", null, locale.failureText));

        case LOAD_STATE.complete:
          return /*#__PURE__*/React.createElement("div", {
            className: cls
          }, /*#__PURE__*/React.createElement("span", null, locale.completeText));

        default:
      }
    };

    _this.state = {
      offsetY: 0,
      animationDuration: 0,
      refreshState: props.refresh.state,
      loadState: props.load.state
    };
    _this.throttledScroll = Throttle(_this.onScroll, 250);
    return _this;
  }

  _createClass(Pull, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.mounted = true;
      this.addEvent();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.addEvent();
      var _this$props4 = this.props,
          load = _this$props4.load,
          refresh = _this$props4.refresh;

      if (prevProps.load.state !== load.state) {
        this.doLoadAction(load.state);
      }

      if (prevProps.refresh.state !== refresh.state) {
        this.doRefreshAction(refresh.state);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      this.removeEvent();
    }
  }, {
    key: "scrollContainer",
    get: function get() {
      var container = function (node) {
        while (node && node.parentNode && node.parentNode !== document.body) {
          var style = window.getComputedStyle(node);

          if ( // overflow 或者 overflowY 值为 scroll/auto
          (['scroll', 'auto'].indexOf(style.overflowY) > -1 || ['scroll', 'auto'].indexOf(style.overflow) > -1) && ( // height 或者 max-height 值大于 0
          parseInt(style.height, 10) > 0 || parseInt(style.maxHeight, 10) > 0)) {
            return node;
          }

          node = node.parentNode;
        }
      }(this.pull) || window;

      return container;
    }
  }, {
    key: "scrollTop",
    get: function get() {
      return getScrollTop(this.wrap);
    } // 该方法即将过期

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props5 = this.props,
          prefixCls = _this$props5.prefixCls,
          className = _this$props5.className,
          style = _this$props5.style,
          children = _this$props5.children;
      var _this$state3 = this.state,
          offsetY = _this$state3.offsetY,
          animationDuration = _this$state3.animationDuration,
          refreshState = _this$state3.refreshState,
          loadState = _this$state3.loadState;
      var cls = classnames(prefixCls, className);
      var loadCls = classnames("".concat(prefixCls, "__load"), _defineProperty({}, "".concat(prefixCls, "__load--show"), loadState >= LOAD_STATE.loading));
      var contentStyle = {
        WebkitTransition: "all ".concat(animationDuration, "ms"),
        transition: "all ".concat(animationDuration, "ms")
      };

      if (refreshState <= REFRESH_STATE.drop) {
        contentStyle.WebkitTransform = "translate3d(0, ".concat(offsetY, "px, 0)");
        contentStyle.transform = "translate3d(0, ".concat(offsetY, "px, 0)");
      }

      return /*#__PURE__*/React.createElement(Drag, {
        onDragMove: this.onDragMove,
        onDragEnd: this.onDragEnd
      }, /*#__PURE__*/React.createElement("div", {
        className: cls,
        style: style
      }, /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "__content"),
        style: contentStyle,
        ref: function ref(ele) {
          _this2.pull = ele;
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "__refresh")
      }, this.renderRefresh()), /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "__body")
      }, children), /*#__PURE__*/React.createElement("div", {
        className: loadCls
      }, this.renderLoad()))));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      var load = nextProps.load,
          refresh = nextProps.refresh;
      var _state$prevLoad = state.prevLoad,
          prevLoad = _state$prevLoad === void 0 ? {} : _state$prevLoad,
          _state$prevRefresh = state.prevRefresh,
          prevRefresh = _state$prevRefresh === void 0 ? {} : _state$prevRefresh;

      if ('load' in nextProps && load.state !== prevLoad.state) {
        return {
          loadState: load.state,
          prevLoad: load
        };
      }

      if ('refresh' in nextProps && refresh.state !== prevRefresh.state) {
        return {
          refreshState: refresh.state,
          prevRefresh: refresh
        };
      }

      return null;
    }
  }]);

  return Pull;
}(PureComponent);

Pull.defaultProps = {
  prefixCls: 'za-pull',
  refresh: {
    state: REFRESH_STATE.normal,
    startDistance: 30,
    distance: 30
  },
  load: {
    state: LOAD_STATE.normal,
    distance: 0
  },
  animationDuration: 400,
  stayTime: 1000
};
export { Pull as default };