"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _utils = require("ts-jest/utils");

var _getFileDetail = _interopRequireDefault(require("../../utils/getFileDetail"));

var _handleFileInfo = _interopRequireDefault(require("../../utils/handleFileInfo"));

var _createThumbnail = _interopRequireDefault(require("../../utils/createThumbnail"));

var _utils2 = require("../../../../tests/utils");

jest.mock('../../utils/getFileDetail');
jest.mock('../../utils/createThumbnail');
var mockedGetFileDetail = (0, _utils.mocked)(_getFileDetail.default);
var mockedCreateThumbnail = (0, _utils.mocked)(_createThumbnail.default);
describe('file-picker', function () {
  describe('utils', function () {
    afterAll(function () {
      jest.resetAllMocks();
    });
    afterEach(function () {
      jest.clearAllMocks();
    });
    describe('#handleFileInfo', function () {
      it('should get file detail if file is not a picture', function () {
        var file = new File(['foo'], 'foo.txt', {
          type: 'text/plain'
        });
        mockedGetFileDetail.mockReturnValueOnce({
          fileSize: 1000,
          fileType: 'zip',
          isPic: false,
          fileName: 'test'
        });
        var callback = jest.fn();
        (0, _handleFileInfo.default)({
          file: file,
          quality: 0.8
        }, callback);
        expect(callback).toBeCalledWith({
          file: file,
          fileName: 'test',
          fileSize: 1000,
          fileType: 'zip',
          thumbnail: ''
        });
        expect(mockedGetFileDetail).toBeCalledWith(file);
      });
      it('should get file detail with thumbnail url', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var file, callback;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                file = new File(['foo'], 'foo.txt', {
                  type: 'text/plain'
                });
                mockedGetFileDetail.mockReturnValueOnce({
                  fileSize: 1000,
                  fileType: 'jpg',
                  isPic: true,
                  fileName: 'avatar'
                });
                mockedCreateThumbnail.mockResolvedValueOnce('http://example.cdn.com');
                callback = jest.fn();
                (0, _handleFileInfo.default)({
                  file: file,
                  quality: 0.8
                }, callback);
                _context.next = 7;
                return (0, _utils2.flushMicroTasks)();

              case 7:
                expect(callback).toBeCalledWith({
                  file: file,
                  fileName: 'avatar',
                  fileSize: 1000,
                  fileType: 'jpg',
                  thumbnail: 'http://example.cdn.com'
                });
                expect(mockedGetFileDetail).toBeCalledWith(file);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
      it('should print error if create thumbnail fail', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var file, err, callback, errorLogStub;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                file = new File(['foo'], 'foo.txt', {
                  type: 'text/plain'
                });
                mockedGetFileDetail.mockReturnValueOnce({
                  fileSize: 1000,
                  fileType: 'jpg',
                  isPic: true,
                  fileName: 'avatar'
                });
                err = new Error('memory leak');
                mockedCreateThumbnail.mockRejectedValueOnce(err);
                callback = jest.fn();
                errorLogStub = jest.spyOn(console, 'error').mockReturnValueOnce();
                (0, _handleFileInfo.default)({
                  file: file,
                  quality: 0.8
                }, callback);
                _context2.next = 9;
                return (0, _utils2.flushMicroTasks)();

              case 9:
                expect(callback).not.toBeCalled();
                expect(mockedGetFileDetail).toBeCalledWith(file);
                expect(errorLogStub).toBeCalledWith(err);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));
    });
  });
});