"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _enzyme = require("enzyme");

var _react = _interopRequireDefault(require("react"));

var _warnIfDeprecated = _interopRequireDefault(require("../warnIfDeprecated"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TestComponent = /*#__PURE__*/function (_React$Component) {
  (0, _inherits2.default)(TestComponent, _React$Component);

  var _super = _createSuper(TestComponent);

  function TestComponent() {
    (0, _classCallCheck2.default)(this, TestComponent);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(TestComponent, [{
    key: "render",
    value: function render() {
      return 'test component';
    }
  }], [{
    key: "nonReactStaticMethod",
    value: function nonReactStaticMethod() {
      return null;
    }
  }]);
  return TestComponent;
}(_react.default.Component);

TestComponent.displayName = 'TestComponent';
describe('utils', function () {
  var oEnv = process.env;
  afterAll(function () {
    process.env = oEnv;
  });
  afterEach(function () {
    jest.restoreAllMocks();
  });
  describe('warnIfDeprecated', function () {
    it('should print warning log if the props of the component has been deprecated', function () {
      process.env.NODE_ENV = 'dev';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([{
        oldProp: 'a',
        newProp: 'b'
      }]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      var props = {
        a: '1',
        b: '2'
      };
      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, props));
      expect(warnLogSpy).toBeCalledWith('Warning: a has been renamed, and is not recommended for use.\n\n* Rename a to b to suppress this warning.');
      expect(warnLogSpy).toBeCalledWith('Please update the following components: TestComponent');
    });
    it('should print warning log when use the deprecated component name', function () {
      process.env.NODE_ENV = 'dev';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([{
        oldComponent: 'TestComponent',
        newComponent: 'NewTestComponent'
      }]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, null));
      expect(warnLogSpy).toBeCalledWith('Warning: TestComponent has been renamed, and is not recommended for use.\n\n* Rename TestComponent to NewTestComponent to suppress this warning.');
      expect(warnLogSpy).toBeCalledWith('Please update the following components: TestComponent');
    });
    it('should print warning log when use the deprecated component name and props', function () {
      process.env.NODE_ENV = 'dev';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([{
        oldProp: 'a',
        newProp: 'b',
        oldComponent: 'TestComponent',
        newComponent: 'NewTestComponent'
      }]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      var props = {
        a: '1',
        b: '2'
      };
      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, props));
      expect(warnLogSpy).toBeCalledWith('Warning: a has been renamed, and is not recommended for use.\n\n* Rename a to b to suppress this warning.');
      expect(warnLogSpy).toBeCalledWith('Please update the following components: TestComponent');
      expect(warnLogSpy).toBeCalledWith('Warning: TestComponent has been renamed, and is not recommended for use.\n\n* Rename TestComponent to NewTestComponent to suppress this warning.');
      expect(warnLogSpy).toBeCalledWith('Please update the following components: TestComponent');
    });
    it('should not print warning log if NODE_ENV is production', function () {
      process.env.NODE_ENV = 'production';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([{
        oldProp: 'a',
        newProp: 'b'
      }]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      var props = {
        a: '1',
        b: '2'
      };
      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, props));
      expect(warnLogSpy).not.toBeCalled();
    });
    it('should not print warning log if deprecations is empty', function () {
      process.env.NODE_ENV = 'dev';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      var props = {
        a: '1',
        b: '2'
      };
      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, props));
      expect(warnLogSpy).not.toBeCalled();
    });
    it('should not print warning log if wrappered component does not have old prop', function () {
      process.env.NODE_ENV = 'dev';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      var props = {
        c: '3'
      };
      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, props));
      expect(warnLogSpy).not.toBeCalled();
    });
    it('should not print warning log if the name of the wrappered component is not equal the old name', function () {
      process.env.NODE_ENV = 'dev';
      var warnLogSpy = jest.spyOn(console, 'warn').mockImplementation(function () {
        return 'suppress warn';
      });
      var wrapper = (0, _warnIfDeprecated.default)([{
        oldComponent: 'WhatEverTestComponent',
        newComponent: 'NewTestComponent'
      }]);
      var WrappedComponent = wrapper(TestComponent); // TODO: use strict types rather than any

      (0, _enzyme.mount)( /*#__PURE__*/_react.default.createElement(WrappedComponent, null));
      expect(warnLogSpy).not.toBeCalled();
    });
  });
});